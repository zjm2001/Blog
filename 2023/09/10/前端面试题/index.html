<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="前端面试题持续更新 ~~~">
<meta property="og:type" content="article">
<meta property="og:title" content="前端经典面试题">
<meta property="og:url" content="https://zjm2001.github.io/2023/09/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="ZJMのBlog">
<meta property="og:description" content="前端面试题持续更新 ~~~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zjm2001.github.io/2023/09/10/images/image-20230910200358658.png">
<meta property="article:published_time" content="2023-09-09T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-27T11:20:02.366Z">
<meta property="article:author" content="ZJM">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zjm2001.github.io/2023/09/10/images/image-20230910200358658.png"><title>前端经典面试题 | ZJMのBlog</title><link ref="canonical" href="https://zjm2001.github.io/2023/09/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"25px","tocMaxDepth":4},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">ZJMの学习日志</div><div class="header-banner-info__subtitle">一个建立于21世纪的Blog，存活在互联网边缘！！！</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><div class="sticky-top" data-popover="置顶文章" data-popover-pos="up"><span class="sticky-top__icon"><i class="fas fa-thumbtack"></i></span></div><h1 class="post-title">前端经典面试题</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-11-27</span></span></div></header><div class="post-body"><div class="gallery"><img src="/../images/image-20230910200358658.png"></div><hr>

        <h1 id="基础知识"   >
          <a href="#基础知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1>
      
        <h2 id="说一下-http与https"   >
          <a href="#说一下-http与https" class="heading-link"><i class="fas fa-link"></i></a><a href="#说一下-http与https" class="headerlink" title="说一下 http与https"></a>说一下 http与https</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">HTTP是用于在Web浏览器和Web服务器之间传输信息的协议，而HTTPS是HTTP协议的安全版本，</span><br><span class="line">通过加密和身份验证确保数据的安全性和真实性。HTTPS使用SSL / TLS协议加密数据传输，并常用于处理敏感信息和保护用户隐私。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>知识点:<br>当谈到HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）时，这两者都是用于在计算机网络上传输数据的协议。<br>HTTP 是一种无状态的协议，它使用TCP作为传输层协议，用于在Web浏览器和Web服务器之间传输信息，常用于页面请求和响应。HTTP的常见端口号是80。<br>然而，HTTPS是在HTTP上加密和身份验证的安全版本。它使用公钥加密算法（如SSL &#x2F; TLS）来保护数据的传输，并确保通信的机密性和完整性。HTTPS的常见端口号是443。<br>HTTP和HTTPS的主要区别在于安全性。HTTPS通过加密和数字证书验证确保了数据的安全性和真实性。在HTTPS中，服务器和浏览器之间的通信是通过使用SSL &#x2F; TLS协议来进行加密和保护的。<br>对于前端开发而言，了解HTTP和HTTPS的基本概念非常重要。当我们在开发网站时，需要考虑使用HTTPS来加强对数据的保护，特别是在进行用户登录、交易或传输敏感信息时。同时，还要了解如何在前端页面中正确地处理HTTP和HTTPS请求，以确保数据的安全性和正确性。</p>
<p>https 协议的缺点 </p>
<ol>
<li><p>https 握手阶段比较费时，</p>
</li>
<li><p>会使页面加载时间延长 50%，增加 10%~20%的耗电。</p>
</li>
<li><p>https 缓存不如 http 高效，会增加数据开销。 SSL 证书也需要钱，功能越强大的证书费用越高。</p>
</li>
<li><p>SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗</p>
</li>
</ol>
</li>
</ul>
<hr>

        <h2 id="TCP的三次握手"   >
          <a href="#TCP的三次握手" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">TCP三次握手是建立TCP连接的一种过程。</span><br><span class="line">首先，客户端发送一个请求连接的SYN报文给服务器。</span><br><span class="line">然后服务器收到并确认客户端的请求，发送一个带有自己SYN和确认号的报文作为回应。</span><br><span class="line">最后，客户端收到服务器的确认后，再发送一个确认报文给服务器。</span><br><span class="line">这样，双方都知道彼此准备好进行数据传输，TCP连接便建立成功。这个过程确保了通信双方的可靠性和同步性，</span><br><span class="line">以保证后续的数据传输的正常进行。</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>知识点:TCP三次握手是在建立TCP连接时的一种握手过程。它确保了通信双方的可靠性和同步性。以下是TCP三次握手的步骤：</p>
<ol>
<li>第一次握手（SYN）：客户端向服务器发送一个SYN报文，请求建立连接。报文中包含随机生成的初始序列号（ISN）。</li>
<li>第二次握手（SYN + ACK）：服务器收到客户端的SYN报文后，确认接收，并发送一个带有自己的SYN和确认号（ACK）的报文作为回应。服务器还会生成自己的初始序列号（ISN）并发送给客户端。</li>
<li>第三次握手（ACK）：客户端收到服务器的确认后，发送一个ACK报文作为回应。该报文中的确认号是服务器发送的SYN + ACK报文的序列号加1。</li>
</ol>
<p>通过这个三次握手过程，两个端点（客户端和服务器）可以确认彼此都已准备好进行数据传输。在握手完成后，TCP连接就建立起来了，双方可以开始传输数据。</p>
</li>
</ul>
<hr>

        <h2 id="TCP-和-UDP-的区别"   >
          <a href="#TCP-和-UDP-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">（1）TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。</span><br><span class="line">（2）TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，</span><br><span class="line">     即不保证可靠交付。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换。</span><br><span class="line">（3）TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包）。</span><br><span class="line">（4）TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。</span><br><span class="line">（5）TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。</span><br><span class="line">（6）TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</span><br></pre></td></tr></table></div></figure>

<hr>

        <h2 id="https常见状态码"   >
          <a href="#https常见状态码" class="heading-link"><i class="fas fa-link"></i></a><a href="#https常见状态码" class="headerlink" title="https常见状态码"></a>https常见状态码</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">    200 OK：请求成功。服务器成功处理了请求并返回了请求的资源。</span><br><span class="line">    301 Moved Permanently：永久重定向。请求的资源被永久移动到其他位置。</span><br><span class="line">    302 Found：临时重定向。请求的资源临时移动到其他位置。</span><br><span class="line">    400 Bad Request：请求错误。服务器无法理解请求的语法或参数。</span><br><span class="line">    401 Unauthorized：未授权。需要身份验证或认证才能访问请求的资源。</span><br><span class="line">    403 Forbidden：禁止访问。服务器拒绝请求访问所请求的资源。</span><br><span class="line">    404 Not Found：未找到。服务器找不到请求的资源。</span><br><span class="line">    500 Internal Server Error：内部服务器错误。服务器在处理请求时遇到了错误。</span><br><span class="line">    502 Bad Gateway：网关错误。作为代理或网关的服务器从上游服务器接收到无效的响应。</span><br><span class="line">    503 Service Unavailable：服务不可用。服务器暂时无法处理请求，通常是由于过载或维护。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<hr>

        <h2 id="输入URL解析过程"   >
          <a href="#输入URL解析过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入URL解析过程" class="headerlink" title="输入URL解析过程"></a>输入URL解析过程</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.DNS解析：将URL中的域名解析为对应的IP地址。</span><br><span class="line">2.建立TCP连接：使用解析得到的IP地址，浏览器与服务器建立TCP连接。</span><br><span class="line">3.发送HTTP请求：浏览器向服务器发送HTTP请求，包括请求的方法、URI和请求头信息。</span><br><span class="line">4.服务器处理请求：服务器接收到请求后，根据请求的URI和方法，处理请求并准备响应。</span><br><span class="line">5.响应HTTP请求：服务器生成HTTP响应，包括状态码、响应头和响应体，并发送回浏览器。</span><br><span class="line">接收并渲染页面：浏览器接收到服务器的响应后，解析响应体中的HTML代码，并构建DOM树。</span><br><span class="line">然后，根据CSS样式和JavaScript代码对页面进行渲染，最终将渲染结果呈现在用户的屏幕上。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<hr>

        <h2 id="GET-和-POST-的区别"   >
          <a href="#GET-和-POST-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">GET是通过URL传递数据，参数暴露在URL上，适合传输少量数据，不安全，可被缓存，幂等性。</span><br><span class="line">POST是通过请求体传递数据，参数不暴露在URL上，适合传输大量数据，安全，不可缓存，不一定具有幂等性</span><br></pre></td></tr></table></div></figure>

<ul>
<li>知识点:</li>
</ul>
<ol>
<li>数据传递方式：GET请求将数据通过URL的查询参数进行传递，数据会附加在URL的后面，例如：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://example.com/path?key1=value1&key2=value2%E3%80%82%E8%80%8CPOST%E8%AF%B7%E6%B1%82%E5%B0%86%E6%95%B0%E6%8D%AE%E5%8C%85%E5%90%AB%E5%9C%A8%E8%AF%B7%E6%B1%82%E4%BD%93%E4%B8%AD%EF%BC%8C%E4%B8%8D%E4%BC%9A%E7%9B%B4%E6%8E%A5%E6%9A%B4%E9%9C%B2%E5%9C%A8URL%E4%B8%AD%E3%80%82" >http://example.com/path?key1=value1&amp;key2=value2。而POST请求将数据包含在请求体中，不会直接暴露在URL中。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>数据长度限制：GET请求的传输数据长度有限制，通常在几千个字符左右。而POST请求没有严格的长度限制，可以传输较大的数据。</li>
<li>数据安全性：GET请求的参数会暴露在URL中，可能被浏览器历史记录、服务器日志记录等所记录，不适合传输敏感信息。POST请求的参数不会直接暴露在URL中，因此相对来说更安全。</li>
<li>缓存：GET请求通常可以被浏览器缓存，因为GET请求无副作用，多次请求同一URL可以从缓存中获取响应。POST请求默认是不可缓存的，因为POST请求可能对服务器端产生副作用。</li>
<li>幂等性：GET请求是幂等的，多次重复请求对服务器产生的结果是一样的，不会产生副作用。而POST请求一般不是幂等的，多次请求可能会产生不同的结果，可能对服务器产生副作用。</li>
</ol>
<hr>

        <h2 id="浏览器常见存储方式"   >
          <a href="#浏览器常见存储方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#浏览器常见存储方式" class="headerlink" title="浏览器常见存储方式"></a>浏览器常见存储方式</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">cookie、sessionStorage和localStorage是在客户端存储数据的三种常见方式，它们之间有一些区别：</span><br><span class="line">    存储位置：</span><br><span class="line">        cookie: 存储在客户端浏览器中，并在每次HTTP请求时都会自动发送到服务器。</span><br><span class="line">        sessionStorage: 存储在浏览器的会话存储空间中，仅在当前会话期间有效，浏览器关闭后会被清除。</span><br><span class="line">        localStorage: 存储在浏览器的持久化存储空间中，除非手动清除，否则会一直保留。</span><br><span class="line">    容量限制：</span><br><span class="line">        cookie: 大小限制为4KB，每个域名下的cookie总数也有限制。</span><br><span class="line">        sessionStorage和localStorage: 大小限制一般为5MB或更大，可以存储较大数量的数据。</span><br><span class="line">    数据生命周期：</span><br><span class="line">        cookie: 可以设置过期时间，存储在客户端并在过期时间之前有效。</span><br><span class="line">        sessionStorage: 仅在当前会话期间有效，即浏览器关闭或标签页关闭后会被清除。</span><br><span class="line">        localStorage: 永久有效，除非手动清除或代码删除。</span><br><span class="line">    数据访问权限：</span><br><span class="line">        cookie: 具有域名访问权限，可以在不同页面、不同标签间共享。</span><br><span class="line">        sessionStorage: 仅对创建数据的页面及其后续页面有效，不同标签页之间数据不共享。</span><br><span class="line">        localStorage: 对创建数据的页面及其后续页面有效，不同标签页之间数据共享。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<hr>
<hr>
<hr>

        <h1 id="HTML基础"   >
          <a href="#HTML基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h1>
      
        <h2 id="对-HTML-语义化标签的理解"   >
          <a href="#对-HTML-语义化标签的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#对-HTML-语义化标签的理解" class="headerlink" title="对 HTML 语义化标签的理解"></a>对 HTML 语义化标签的理解</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">    语义化的HTML是一种合理使用具有适当语义的HTML元素的编码方式。</span><br><span class="line">    使用正确的标签描述内容，使代码具有良好的结构和可读性。</span><br><span class="line">    语义化的HTML有助于提高可访问性、SEO友好以及代码的可维护性。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>常见语义化标签:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;：定义文档或节的页眉，通常包含网站的logo、导航栏和页面的标题。</span><br><span class="line">&lt;nav&gt;：用于定义页面的导航部分，包含页面的主要导航链接。</span><br><span class="line">&lt;main&gt;：定义文档的主要内容，每个文档只能有一个&lt;main&gt;标签。</span><br><span class="line">&lt;article&gt;：用于定义独立的文章或内容块，如博客文章、新闻报道等。</span><br><span class="line">&lt;section&gt;：用于将相关内容组织在一起，如页面的不同章节、主题内容等。</span><br><span class="line">&lt;aside&gt;：定义页面的附属内容，通常是侧边栏、辅助栏或广告等。</span><br><span class="line">&lt;footer&gt;：定义文档或节的页脚，通常包含版权信息、联系方式等。</span><br><span class="line">&lt;figure&gt;和&lt;figcaption&gt;：&lt;figure&gt;用于包含媒体内容（如图片、音频、视频等），而&lt;figcaption&gt;则用于给媒体内容添加标题或说明。</span><br><span class="line">&lt;time&gt;：用于标记时间，可以表示具体的日期、时间或日期时间。</span><br><span class="line">&lt;mark&gt;：用于标记文本中的突出部分，通常用黄色背景突出显示。</span><br></pre></td></tr></table></div></figure></li>
</ul>
<hr>

        <h2 id="Doctype-的作用是什么"   >
          <a href="#Doctype-的作用是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#Doctype-的作用是什么" class="headerlink" title="Doctype 的作用是什么"></a>Doctype 的作用是什么</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">    Doctype（文档类型声明）指示浏览器使用哪种HTML规范解析文档。</span><br><span class="line">    它告诉浏览器如何处理页面的渲染模式和布局。</span><br><span class="line">    Doctype声明必须在HTML文档的开头进行指定，否则浏览器可能会以混杂模式解析页面。</span><br><span class="line">    混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面</span><br></pre></td></tr></table></div></figure>

<hr>

        <h2 id="如何优化网页的加载性能"   >
          <a href="#如何优化网页的加载性能" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何优化网页的加载性能" class="headerlink" title="如何优化网页的加载性能"></a>如何优化网页的加载性能</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">   </span><br><span class="line">    使用合适的Doctype声明，以避免浏览器进入混杂模式。</span><br><span class="line">    将CSS样式表放在页面的 &lt;head&gt; 标签中，并进行合理的压缩和合并。</span><br><span class="line">    将JavaScript脚本放在页面底部，或使用异步加载或延迟加载。</span><br><span class="line">    优化图片，使用适当的格式、压缩和懒加载等。</span><br><span class="line">    使用浏览器缓存和CDN来加速资源加载。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<hr>

        <h2 id="meta标签的作用"   >
          <a href="#meta标签的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#meta标签的作用" class="headerlink" title="meta标签的作用"></a>meta标签的作用</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">   &lt;meta&gt; 标签是HTML中的元数据标签，用于提供关于网页的元数据信息。</span><br><span class="line">   它通常位于文档的 &lt;head&gt; 部分，提供关于网页的描述、字符编码、视口设置等</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>知识点:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">charset：  指定文档的字符编码，如 &lt;meta charset=&quot;UTF-8&quot;&gt;。</span><br><span class="line">name 和 content：   用于指定元数据的名称和值，如 &lt;meta name=&quot;description&quot; content=&quot;网页描述&quot;&gt;。</span><br><span class="line">http-equiv 和 content：用于提供与HTTP相关的元数据，如&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5;url=example.com&quot;&gt; </span><br><span class="line">                       用于设置页面的自动刷新。</span><br><span class="line">viewport：用于定义可视区域的设置，特别用于响应式设计，如 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">          用于确保适应不同设备的屏幕宽度。</span><br><span class="line">name=&quot;robots&quot;：用于控制搜索引擎爬虫的行为，如&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt; 用于指示允许搜索引擎索引页面并跟踪链接。</span><br><span class="line">name=&quot;author&quot;：用于指定网页作者。</span><br><span class="line">name=&quot;keywords&quot;：用于指定网页关键词。</span><br><span class="line">http-equiv=&quot;X-UA-Compatible&quot;：用于控制浏览器的兼容性模式，如 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; </span><br><span class="line">                              用于告诉IE使用最新版本的渲染引擎。</span><br></pre></td></tr></table></div></figure></li>
</ul>
<hr>

        <h2 id="a-标签的-href-属性和-target-属性"   >
          <a href="#a-标签的-href-属性和-target-属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#a-标签的-href-属性和-target-属性" class="headerlink" title="a 标签的 href 属性和 target 属性"></a>a 标签的 href 属性和 target 属性</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">  href 属性是 &lt;a&gt; 标签中最重要的属性之一。它指定了链接的目标URL，可以是其他网页、文件、锚点或电子邮件地址等</span><br><span class="line">  target 属性用于指定链接在何处打开。常见的取值有:</span><br><span class="line">  _blank：在新的浏览器窗口或标签页中打开链接。</span><br><span class="line">  _self：在当前窗口或标签页中打开链接（默认值）。</span><br><span class="line">  </span><br></pre></td></tr></table></div></figure>

<hr>

        <h2 id="img标签的常用属性及其作用"   >
          <a href="#img标签的常用属性及其作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#img标签的常用属性及其作用" class="headerlink" title="img标签的常用属性及其作用"></a>img标签的常用属性及其作用</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">回答:</span><br><span class="line">   src：用于指定图像文件的URL，必填属性。</span><br><span class="line">   alt：用于提供图像的替代文本，用于在图像无法显示时展示给用户。建议提供有意义的描述</span><br><span class="line">   title：用于提供图像的额外提示信息，通常在鼠标悬停时显示</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<hr>

        <h2 id="HTML5-对比-4-有哪些不同之处？"   >
          <a href="#HTML5-对比-4-有哪些不同之处？" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTML5-对比-4-有哪些不同之处？" class="headerlink" title="HTML5 对比 4 有哪些不同之处？"></a>HTML5 对比 4 有哪些不同之处？</h2>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/../images/image-20231009094913211.png"  alt="image-20231009094913211">
      </p>
<p>contenteditable添加这个属性后可以直接进行修改标签内容选项</p>
<p>draggable这个属性必须写全等于true 使用后的标签可以进行拖拽</p>
<p>hidden属性相当于display:none进行隐藏使用</p>

        <h1 id="CSS基础"   >
          <a href="#CSS基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1>
      
        <h2 id="CSS选择器优先级"   >
          <a href="#CSS选择器优先级" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSS选择器优先级" class="headerlink" title="CSS选择器优先级"></a>CSS选择器优先级</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ID选择器：100。</span><br><span class="line">类选择器、属性选择器和伪类选择器：10。</span><br><span class="line">元素选择器和伪元素选择器：1。</span><br><span class="line">行内样式拥有比选择器优先级更高的优先级(css层叠是用同为相加)</span><br><span class="line">还有一些特殊情况，例如使用 !important 关键字或者内联样式表会影响选择器的优先级。!important 关键字会使规则具有最高的优先级</span><br></pre></td></tr></table></div></figure>


        <h2 id="隐藏元素方法"   >
          <a href="#隐藏元素方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#隐藏元素方法" class="headerlink" title="隐藏元素方法"></a>隐藏元素方法</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">display: none;：这是最常见的一种隐藏元素的方法。通过将元素的显示属性设置为 none，</span><br><span class="line">可以完全隐藏该元素，并且不会在页面中占据任何空间。</span><br><span class="line">visibility: hidden;：通过将元素的可见性属性设置为 hidden，可以隐藏元素，但该元素仍然占据页面中的空间。</span><br><span class="line">opacity: 0;：通过将元素的透明度属性设置为 0，可以使元素变得完全透明，从而达到隐藏的效果。</span><br><span class="line">与 display: none; 不同，该方法仍然保留元素在文档流中的位置。</span><br><span class="line">position: absolute; 或 position: fixed;：通过将元素的定位属性设置为 absolute 或 fixed，</span><br><span class="line">并设置 left 或 top 属性将元素移出屏幕之外，实现元素的隐藏效果。这种方法可以用于隐藏某个特定区域或元素。</span><br><span class="line">transform: scale(0);属性可以用来改变元素的大小，并且也可以通过设置缩放值来实现隐藏效果。</span><br><span class="line">但需要注意的是，使用缩放来隐藏元素可能会导致元素仍然占据页面中的空间。</span><br></pre></td></tr></table></div></figure>


        <h2 id="让元素居中的方式"   >
          <a href="#让元素居中的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#让元素居中的方式" class="headerlink" title="让元素居中的方式"></a>让元素居中的方式</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.水平垂直居中（Flexbox）：使用 Flexbox 布局可以很方便地实现元素的水平和垂直居中。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center; /* 水平居中 */</span><br><span class="line">  align-items: center; /* 垂直居中 */</span><br><span class="line">&#125;</span><br><span class="line">2.水平垂直居中（Grid）：使用 CSS Grid 布局也可以实现元素的水平和垂直居中。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  place-items: center; /* 水平垂直居中 */</span><br><span class="line">&#125;</span><br><span class="line">3.水平居中（块级元素）：对于块级元素，可以使用 margin 属性将左右外边距设置为 &quot;auto&quot; 来实现水平居中。</span><br><span class="line">.element &#123;</span><br><span class="line">  margin-left: auto;</span><br><span class="line">  margin-right: auto;</span><br><span class="line">&#125;</span><br><span class="line">4.水平居中（行内元素）：对于行内元素，可以使用父容器的 text-align 属性来实现水平居中。</span><br><span class="line">.container &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">5.水平垂直居中（绝对定位）：使用绝对定位结合 transform 属性可以实现元素的水平和垂直居中。</span><br><span class="line">.element &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="定位"   >
          <a href="#定位" class="heading-link"><i class="fas fa-link"></i></a><a href="#定位" class="headerlink" title="定位"></a>定位</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">静态定位（Static Positioning）：这是元素默认的定位方式。静态定位的元素根据正常文档流进行布局，不受其他定位方式的影响。</span><br><span class="line"></span><br><span class="line">相对定位（Relative Positioning）：通过设置position: relative;</span><br><span class="line">可以将元素相对于其原始位置进行定位。相对定位时，可以使用top、right、bottom和left属性来指定元素相对于其原始位置的偏移量。</span><br><span class="line"></span><br><span class="line">绝对定位（Absolute Positioning）：通过设置position: absolute;</span><br><span class="line">可以将元素相对于最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于文档的初始坐标进行定位。绝对定位时，可以使用top、right、bottom和left属性来指定元素相对于其定位参考点的偏移量。</span><br><span class="line"></span><br><span class="line">固定定位（Fixed Positioning）：通过设置position: fixed;</span><br><span class="line">可以将元素相对于浏览器窗口进行定位，即使页面滚动，元素也会保持在固定的位置。固定定位时，</span><br><span class="line">可以使用top、right、bottom和left属性来指定元素相对于浏览器窗口的偏移量。</span><br><span class="line"></span><br><span class="line">粘性定位（Sticky Positioning）：通过设置position: sticky;</span><br><span class="line">可以将元素相对于其父元素或视口进行定位。粘性定位的元素在滚动到特定位置时会变为固定定位，否则按照正常文档流进行布局</span><br></pre></td></tr></table></div></figure>


        <h2 id="css中的大小单位"   >
          <a href="#css中的大小单位" class="heading-link"><i class="fas fa-link"></i></a><a href="#css中的大小单位" class="headerlink" title="css中的大小单位"></a>css中的大小单位</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">px（像素）：px是绝对长度单位，表示相对于显示设备的物理像素。它是最常用的单位，通常用于制定具体的尺寸。</span><br><span class="line"></span><br><span class="line">em：em是相对长度单位，它相对于父元素的字体大小来计算。如果一个元素的字体大小是16px，那么设置为1em，就相当于16px。</span><br><span class="line">如果嵌套在另一个元素中，其父元素的字体大小为20px，那么1em就相当于20px。通常用于调整字体大小。</span><br><span class="line"></span><br><span class="line">rem：rem也是相对长度单位，但它相对于根元素（即html元素）的字体大小来计算。与em不同，rem是相对于根元素的字体大小而不是父元素的字体大小。</span><br><span class="line">它通常用于制作响应式布局。例如，如果根元素的字体大小是16px，那么设置为1rem就等于16px，而无论嵌套在任何元素中。</span><br><span class="line"></span><br><span class="line">vw（视窗宽度）和vh（视窗高度）：vw和vh是相对于视口宽度和视口高度的单位。1vw等于视口宽度的1%，1vh等于视口高度的1%。</span><br><span class="line">它们通常用于制作响应式布局，并可以根据视口大小自动调整元素的尺寸。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="css清除浮动"   >
          <a href="#css清除浮动" class="heading-link"><i class="fas fa-link"></i></a><a href="#css清除浮动" class="headerlink" title="css清除浮动"></a>css清除浮动</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">造成原因:浮动脱离标准流,不占位置(父盒子不会被撑开)</span><br><span class="line">解决方法</span><br><span class="line">1.定高法:直接给父亲写固定高度</span><br><span class="line">2.添加一个盒子给盒子一个(clear:both;)</span><br><span class="line">3.overflow:hidden; 溢出隐藏,出发了BFC,解决了浮动影响</span><br><span class="line">4.利用伪元素的方法  并将其应用于父元素。</span><br><span class="line">.clearfix::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: table;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="谈谈你对BFC的理解"   >
          <a href="#谈谈你对BFC的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#谈谈你对BFC的理解" class="headerlink" title="谈谈你对BFC的理解"></a>谈谈你对BFC的理解</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BFC，即块级格式化上下文（Block Formatting Context），是CSS中一个非常重要的概念。BFC是页面上一个独立的渲染区域，决定了其中元素的布局及相互影响。</span><br><span class="line"></span><br><span class="line">BFC的形成：一个元素会成为一个BFC，如果满足以下条件之一：</span><br><span class="line">    根元素（&lt;html&gt;）</span><br><span class="line">    浮动元素（float属性不为none）</span><br><span class="line">    绝对定位元素（position为absolute或fixed）</span><br><span class="line">    行内块元素（display为inline-block）</span><br><span class="line">    overflow值不为visible的块级元素</span><br><span class="line">BFC应用:</span><br><span class="line">1.处理块级元素的上下合并问题</span><br><span class="line">2.处理margin塌陷</span><br><span class="line">3.清除浮动</span><br><span class="line">4.实现自适应布局</span><br><span class="line"> 左边固定,右边自适应</span><br><span class="line"> flex==&gt;display:flex,左边定宽,右边flex:1</span><br><span class="line"> 浮动 ==&gt; 先浮动占位置,再中间盒子overflow:hidden</span><br><span class="line"> 定位 ==&gt; 先定位,再设置padding即可</span><br></pre></td></tr></table></div></figure>


        <h2 id="什么是CSS-Sprites以及它的好处"   >
          <a href="#什么是CSS-Sprites以及它的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是CSS-Sprites以及它的好处" class="headerlink" title="什么是CSS Sprites以及它的好处"></a>什么是CSS Sprites以及它的好处</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">精灵图/雪碧图</span><br><span class="line">是一种优化网页加载性能的技术，它将多个小的图像合并成一个大的图像，并通过CSS的background-position属性来显示所需部分的图像</span><br><span class="line"></span><br><span class="line">减少HTTP请求数量：在使用CSS Sprites之前，每个小图像都需要发送一个HTTP请求。</span><br><span class="line">而使用CSS Sprites后，只需要发送一个HTTP请求来加载合并后的大图像，从而减少了页面加载时的HTTP请求数量。</span><br><span class="line">这可以有效降低加载时间，提升网页性能。</span><br><span class="line"></span><br><span class="line">减小图像文件大小：合并后的大图像通常会比原始的小图像文件大小更小。</span><br><span class="line">这是因为合并后的图像可以更好地利用图像压缩算法，从而减小文件大小。较小的文件大小也有助于减少网络传输的时间和成本。</span><br><span class="line"></span><br><span class="line">提高渲染速度：浏览器在下载完毕CSS Sprites图像后，只需要渲染一次该图像，</span><br><span class="line">然后使用不同的background-position来显示需要的部分。相比多次渲染多个小图像，这种方式可以显著提高渲染速度，尤其是在含有大量图像的页面上。</span><br><span class="line"></span><br><span class="line">更好的用户体验：由于CSS Sprites能够减少页面加载时间和渲染时间，</span><br><span class="line">网页的响应速度会更快，用户可以更快地浏览和交互。这可以提供更好的用户体验，减少用户的等待时间和流失率。</span><br><span class="line"></span><br><span class="line">注意:CSS Sprites适用于小图标、按钮、背景图等多个小图像的场景。对于大型图像或者需要动态修改的图像，不适合使用CSS Sprites。</span><br></pre></td></tr></table></div></figure>


        <h2 id="你对盒子模型的理解"   >
          <a href="#你对盒子模型的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#你对盒子模型的理解" class="headerlink" title="你对盒子模型的理解"></a>你对盒子模型的理解</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">所有元素都表示为一个个矩形的盒子，再用 CSS 去决定这些盒子的大小尺寸、显示位置、以及其他属性（如颜色、背景、边框等）。</span><br><span class="line">盒模型它由以下几部分组成</span><br><span class="line">内容 content</span><br><span class="line">内边距 padding</span><br><span class="line">边框 border</span><br><span class="line">外边距 margin</span><br><span class="line"></span><br><span class="line">盒子模型分为两种类型:</span><br><span class="line">在CSS3中，我们可以通过设置 box-sizing 的值来决定具体使用何种盒模型：</span><br><span class="line">content-box 标准盒模型</span><br><span class="line">border-box 怪异盒模型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">标准盒模型计算大小 content+padding +margin+border   </span><br><span class="line">怪异盒模型计算大小  </span><br><span class="line">在怪异盒模型下，元素的 width 和 height 值却不是 content 的实际宽高，而是去除 margin 后剩下的元素占用区域的宽高</span><br><span class="line">盒子占据页面宽度 = margin + width + margin</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="你对Flex布局的理解"   >
          <a href="#你对Flex布局的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#你对Flex布局的理解" class="headerlink" title="你对Flex布局的理解"></a>你对Flex布局的理解</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zjm2001.gitee.io/2023/08/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/" >链接地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可查看我的专题  移动端布局   查看flex具体理解</span><br></pre></td></tr></table></div></figure>

<hr>

        <h1 id="javaScript基础"   >
          <a href="#javaScript基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#javaScript基础" class="headerlink" title="javaScript基础"></a>javaScript基础</h1>
      
        <h2 id="解释下什么是变量声明提升"   >
          <a href="#解释下什么是变量声明提升" class="heading-link"><i class="fas fa-link"></i></a><a href="#解释下什么是变量声明提升" class="headerlink" title="解释下什么是变量声明提升"></a>解释下什么是变量声明提升</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。</span><br><span class="line">JS引擎在运行一份代码的时候，会按照下面的步骤进行工作：</span><br><span class="line">1. 首先，对代码进行预解析，并获取声明的所有变量</span><br><span class="line">2. 然后，将这些变量的声明语句统一放到代码的最前面</span><br><span class="line">3. 最后，开始一行一行运行代码</span><br><span class="line">例如:</span><br><span class="line">console.log(a) </span><br><span class="line">var a = 1 </span><br><span class="line">function b() &#123; </span><br><span class="line">  console.log(a)           </span><br><span class="line">&#125;</span><br><span class="line">b() // 1</span><br><span class="line">执行的步骤</span><br><span class="line">1. JS引擎将 `var a = 1` 分解为两个部分：变量声明语句 `var a = undefined` 和变量赋值语句 `a = 1` </span><br><span class="line">2. JS引擎将 `var a = undefined` 放到代码的最前面，而 `a = 1` 保留在原地 </span><br><span class="line">变量的这一转换过程，就被称为变量的声明提升。</span><br><span class="line">而这是不规范, 不合理的, 我们用的  let 就没有这个变量提升的问题</span><br></pre></td></tr></table></div></figure>


        <h2 id="JS-的参数是以什么方式进行传递的"   >
          <a href="#JS-的参数是以什么方式进行传递的" class="heading-link"><i class="fas fa-link"></i></a><a href="#JS-的参数是以什么方式进行传递的" class="headerlink" title="JS 的参数是以什么方式进行传递的"></a>JS 的参数是以什么方式进行传递的</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型和复杂数据类型的数据在传递时，会有不同的表现。</span><br><span class="line">基本类型：是值传递</span><br><span class="line">基本类型的传递方式比较简单，是按照 `值传递` 进行的。</span><br><span class="line">复杂类型: 传递的是地址! (变量中存的就是地址)</span><br></pre></td></tr></table></div></figure>


        <h2 id="JS垃圾回收是怎么做的"   >
          <a href="#JS垃圾回收是怎么做的" class="heading-link"><i class="fas fa-link"></i></a><a href="#JS垃圾回收是怎么做的" class="headerlink" title="JS垃圾回收是怎么做的"></a>JS垃圾回收是怎么做的</h2>
      <p>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。</p>
<p>正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题，</p>
<p>但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。</p>

        <h3 id="内存的生命周期"   >
          <a href="#内存的生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h3>
      <ol>
<li><p>内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</p>
</li>
<li><p>内存使用：即读写内存，也就是使用变量、函数等</p>
</li>
<li><p>内存回收：使用完毕，由垃圾回收自动回收不再使用的内存</p>
<p>全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉</p>
</li>
</ol>

        <h3 id="垃圾回收算法说明"   >
          <a href="#垃圾回收算法说明" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收算法说明" class="headerlink" title="垃圾回收算法说明"></a>垃圾回收算法说明</h3>
      <p>所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉</p>
<p>下面介绍两种常见的浏览器垃圾回收算法: 引用计数 和 标记清除法</p>

        <h4 id="引用计数"   >
          <a href="#引用计数" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4>
      <p>IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。</p>
<p>如果没有任何变量指向它了，说明该对象已经不再需要了。</p>
<p><strong>但它却存在一个致命的问题：循环引用。</strong></p>
<p>如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。</p>

        <h4 id="标记清除算法"   >
          <a href="#标记清除算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4>
      <p>现代的浏览器已经不再使用引用计数算法了。</p>
<p>现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。</p>
<p>标记清除法:</p>
<ul>
<li><p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 </p>
</li>
<li><p>简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。</p>
</li>
<li><p>凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p>
</li>
</ul>
<p>从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。</p>
<p>参考文章:<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/84a8fd5fa0ee" >JavaScript内存管理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<hr>

        <h2 id="谈谈你对-JS作用域链的理解"   >
          <a href="#谈谈你对-JS作用域链的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#谈谈你对-JS作用域链的理解" class="headerlink" title="谈谈你对 JS作用域链的理解"></a>谈谈你对 JS作用域链的理解</h2>
      <p>JavaScript 在执⾏过程中会创建一个个的<strong>可执⾏上下⽂</strong>。 (每个函数执行都会创建这么一个可执行上下文)</p>
<p>每个可执⾏上下⽂的词法环境中包含了对外部词法环境的引⽤，可通过该引⽤来获取外部词法环境中的变量和声明等。</p>
<p>这些引⽤串联起来，⼀直指向全局的词法环境，形成一个链式结构，被称为作⽤域链。</p>
<p>简而言之: 函数内部 可以访问到 函数外部作用域的变量,  而外部函数还可以访问到全局作用域的变量,</p>
<p>这样的变量作用域访问的链式结构, 被称之为作用域链</p>
<p>js全局有全局可执行上下文, 每个函数调用时, 有着函数的可执行上下文, 会入js调用栈</p>
<p>每个可执行上下文, 都有者对于外部上下文词法作用域的引用, 外部上下文也有着对于再外部的上下文词法作用域的引用 </p>
<p><strong>&#x3D;&gt; 就形成了作用域链</strong></p>

        <h2 id="谈谈你对闭包的理解"   >
          <a href="#谈谈你对闭包的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#谈谈你对闭包的理解" class="headerlink" title="谈谈你对闭包的理解"></a>谈谈你对闭包的理解</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">闭包=内层函数+外层函数的变量</span><br><span class="line">作用:封闭数据,提供操作,外部也可以访问函数内部的变量(保证数据的私密性)</span><br><span class="line">问题:可能会引起内存泄漏</span><br><span class="line">基本格式:</span><br><span class="line">function outer() &#123;</span><br><span class="line">  let i =1</span><br><span class="line">function fn()&#123;</span><br><span class="line">  log(i)</span><br><span class="line">&#125;</span><br><span class="line">return fn</span><br><span class="line">&#125;</span><br><span class="line">const fun =outer()</span><br><span class="line">fun()</span><br></pre></td></tr></table></div></figure>


        <h2 id="谈谈你对原型链的理解"   >
          <a href="#谈谈你对原型链的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#谈谈你对原型链的理解" class="headerlink" title="谈谈你对原型链的理解"></a>谈谈你对原型链的理解</h2>
      <p>要讲清楚这个问题，主要着重这几个方面：</p>
<ul>
<li><p>什么是原型对象</p>
</li>
<li><p>构造函数, 原型对象, 实例的三角关系图</p>
</li>
<li><p>原型链如何形成</p>
</li>
<li><pre><code>利用原型解决构造函数方法内存浪费问题
1.prototype  原型对象   每一个构造函数都有一个prototype属性  指向另一个对象 
我们可以吧不变的方法直接定义再prototype对象上 这样所有对象实例就可以共享
2.原型对象里面的函数this指向还是实例对象
3.prototype中的constructor用来指向是哪一个函数
如果我们修改了原来的原型对象,给原型对象赋值的是一个对象
则必须手动利用constructor指回原来的构造函数
4.对象原型__proto__指向构造函数的prototype原型对象
注意__proto__非js标准[[prototype]]意义相同 只读属性 也有一个指向创建该实例的counstructor
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20231127104741195](../images/image-20231127104741195.png)</span><br><span class="line"></span><br><span class="line">## 谈谈对于继承的理解</span><br><span class="line"></span><br><span class="line">### 原型继承</span><br><span class="line"></span><br><span class="line">原型继承: 通过改造原型链, 利用原型链的语法, 实现继承方法!</span><br><span class="line"></span><br><span class="line">定义Person构造函数</span><br><span class="line">定义Student构造函数</span><br><span class="line">原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span><br><span class="line">语法: 子构造函数.prototype = new 父构造函数()</span><br><span class="line"></span><br><span class="line">![image-20231127191556841](../images/image-20231127191556841.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 组合继承</span><br><span class="line"></span><br><span class="line">组合继承有时候也叫伪经典继承，指的是将原型链 和 借用构造函数 call 技术组合到一块，</span><br><span class="line"></span><br><span class="line">从而发挥二者之长的一种继承模式，其背后的思路: **是使用原型链实现对原型属性和方法的继承 (主要是方法)，**</span><br><span class="line"></span><br><span class="line">**而通过借用构造函数来实现对实例属性构造的继承**。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它的自己的属性。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
// 1. 定义Person构造函数
function Person (name, age) &#123;
this.name = name
this.age = age
&#125;
Person.prototype.say = function () &#123;
console.log(&#39;人类会说话&#39;)
&#125;
</code></pre>
</li>
</ul>
<p>&#x2F;&#x2F; 2. 定义Student构造函数<br>function Student (name, age, className) {<br>  Person.call(this, name, age) &#x2F;&#x2F; 实现构造属性的继承<br>  this.className &#x3D; className<br>}<br>&#x2F;&#x2F; 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法<br>&#x2F;&#x2F; 语法: 子构造函数.prototype &#x3D; new 父构造函数()<br>Student.prototype &#x3D; new Person()<br>Student.prototype.study &#x3D; function() {<br>  console.log(‘学生在学习’)<br>}<br>let stu &#x3D; new Student(‘张三’, 18, ‘80期’)<br>stu.say()<br>console.log(stu)<br>&#x2F;&#x2F; 方法通过 原型继承<br>&#x2F;&#x2F; 属性通过 父构造函数的.call(this, name, age)</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 寄生组合继承</span><br><span class="line"></span><br><span class="line">student实例上有 name age,  而原型 `__proto__`上不需要再有这些属性, 所以利用 Object.create 改装下</span><br><span class="line"></span><br><span class="line">Object.create(参数对象),  </span><br><span class="line"></span><br><span class="line">1. Object.create 会创建一个新对象,</span><br><span class="line">2. 并且这个新对象的`__proto__` 会指向传入的参数对象</span><br><span class="line"></span><br><span class="line">![image-20231127191824970](../images/image-20231127191824970.png)</span><br><span class="line"></span><br><span class="line">### es6 - class 实现继承 extends</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>&#x2F;&#x2F; 继承关键字 &#x3D;&gt; extends<br>class Person {<br>  constructor (name, age) {<br>    this.name &#x3D; name<br>    this.age &#x3D; age<br>  }<br>  jump () {<br>    console.log(‘会跳’)<br>  }<br>}</p>
<p>class Teacher extends Person {<br>  constructor (name, age, lesson) {<br>    super(name, age) &#x2F;&#x2F; extends 中, 必须调用 super(), 会触发执行父类的构造函数<br>    this.lesson &#x3D; lesson<br>    console.log(‘构造函数执行了’)<br>  }<br>  sayHello () {<br>    console.log(‘会打招呼’)<br>  }<br>}</p>
<p>let teacher1 &#x3D; new Teacher(‘zs’, 18, ‘体育’)<br>console.log(teacher1)</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 如何判断是否是数组？</span><br><span class="line"></span><br><span class="line">方法一：使用 `toString` 方法</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function isArray(arg) &#123;</span><br><span class="line">	return Object.prototype.toString.call(arg) === &#x27;[object Array]&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [1,2,3]</span><br><span class="line">isArray(arr)  // true</span><br></pre></td></tr></table></div></figure>

<p>方法二：使用 ES6 新增的 <code>Array.isArray</code> 方法</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) <span class="comment">// true</span></span><br></pre></td></tr></table></div></figure>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://zjm2001.github.io">ZJM</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://zjm2001.github.io/2023/09/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">https://zjm2001.github.io/2023/09/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://zjm2001.github.io/tags/%E5%89%8D%E7%AB%AF/">前端</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://zjm2001.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/09/14/javascriptBom%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%89%B9%E6%95%88/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">javascript的Bom与特效</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2023/09/07/javascript%E8%8A%82%E7%82%B9%E4%B8%8E%E4%BA%8B%E4%BB%B6/"><span class="paginator-prev__text">javascript的节点操作与事件</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">
          基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-http%E4%B8%8Ehttps"><span class="toc-number">1.1.</span> <span class="toc-text">
          说一下 http与https</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.2.</span> <span class="toc-text">
          TCP的三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">
          TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.4.</span> <span class="toc-text">
          https常见状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5URL%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">
          输入URL解析过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">
          GET 和 POST 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">
          浏览器常见存储方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">
          HTML基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9-HTML-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">
          对 HTML 语义化标签的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Doctype-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.</span> <span class="toc-text">
          Doctype 的作用是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BD%91%E9%A1%B5%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%80%A7%E8%83%BD"><span class="toc-number">2.3.</span> <span class="toc-text">
          如何优化网页的加载性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#meta%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">
          meta标签的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-%E6%A0%87%E7%AD%BE%E7%9A%84-href-%E5%B1%9E%E6%80%A7%E5%92%8C-target-%E5%B1%9E%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">
          a 标签的 href 属性和 target 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#img%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">
          img标签的常用属性及其作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML5-%E5%AF%B9%E6%AF%94-4-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">
          HTML5 对比 4 有哪些不同之处？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">
          CSS基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.1.</span> <span class="toc-text">
          CSS选择器优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">
          隐藏元素方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A9%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">
          让元素居中的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.4.</span> <span class="toc-text">
          定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E4%B8%AD%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8D%95%E4%BD%8D"><span class="toc-number">3.5.</span> <span class="toc-text">
          css中的大小单位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">3.6.</span> <span class="toc-text">
          css清除浮动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9BFC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.7.</span> <span class="toc-text">
          谈谈你对BFC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCSS-Sprites%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.8.</span> <span class="toc-text">
          什么是CSS Sprites以及它的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.9.</span> <span class="toc-text">
          你对盒子模型的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9Flex%E5%B8%83%E5%B1%80%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.10.</span> <span class="toc-text">
          你对Flex布局的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#javaScript%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">
          javaScript基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="toc-number">4.1.</span> <span class="toc-text">
          解释下什么是变量声明提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%A5%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E4%BC%A0%E9%80%92%E7%9A%84"><span class="toc-number">4.2.</span> <span class="toc-text">
          JS 的参数是以什么方式进行传递的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="toc-number">4.3.</span> <span class="toc-text">
          JS垃圾回收是怎么做的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.3.1.</span> <span class="toc-text">
          内存的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-number">4.3.2.</span> <span class="toc-text">
          垃圾回收算法说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">
          引用计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">
          标记清除算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.4.</span> <span class="toc-text">
          谈谈你对 JS作用域链的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.5.</span> <span class="toc-text">
          谈谈你对闭包的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.6.</span> <span class="toc-text">
          谈谈你对原型链的理解</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/tx.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">握不住的沙，不如扬了它</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/zjm2001" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://res.abeim.cn/api/qq/?qq=2215539769" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">QQ 邮箱</span></a><a class="sidebar-ov-social-item" href="https://res.abeim.cn/api/qq/?qq=2215539769" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">18</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">25</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>ZJM</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="150" alpha="0.5" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script>function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'zjm2001/comment');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (false) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (false) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.xml"></script></body></html>